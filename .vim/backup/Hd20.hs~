module Hd20 where

import Data.List (sort)
import System.Random

type RollCount    = Int
type DropCount    = Int
type SuccessCount = Int
type SideCount    = Int
type SideList     = [Int]
type Total        = Int

data DiceType = Dice RollCount SideCount
              | CustomDice RollCount SideList
              | Constant Int

data DiceExpression = DiceExpr     DiceType
                    | AddExpr      DiceExpression DiceExpression
                    | SubtractExpr DiceExpression DiceExpression
                    | MultiplyExpr DiceExpression DiceExpression
                    | DivideExpr   DiceExpression DiceExpression
                    | MinTotalExpr DiceExpression DiceExpression
                    | MaxTotalExpr DiceExpression DiceExpression
                    | DropLowExpr  DropCount      DiceExpression
                    | DropHighExpr DropCount      DiceExpression
                    | SuccessExpr  SuccessCount   DiceExpression
                    | MinValueExpr DiceExpression
                    | MaxValueExpr DiceExpression

data DiceResult = DiceResult     [Int]
                | AddResult      DiceResult   DiceResult
                | SubtractResult DiceResult   DiceResult
                | MultiplyResult DiceResult   DiceResult
                | DivideResult   DiceResult   DiceResult
                | MinTotalResult DiceResult   DiceResult
                | MaxTotalResult DiceResult   DiceResult
                | DropLowResult  DropCount    DiceResult
                | DropHighResult DropCount    DiceResult
                | SuccessResult  SuccessCount DiceResult
                | MinValueResult DiceResult
                | MaxValueResult DiceResult


{- Show Instances -}

instance Show DiceType where
    show (Dice       r n    ) = show r ++ "d" ++ show n
    show (CustomDice r sides) = show r ++ "d" ++ show sides
    show (Constant   n      ) = show n

instance Show DiceExpression where
    show (DiceExpr     d)      = show d
    show (AddExpr      e1 e2)  = show e1 ++ " + " ++ show e2 
    show (SubtractExpr e1 e2)  = show e1 ++ " - " ++ show e2 ++ "]"
    show (MultiplyExpr e1 e2)  = show e1 ++ " * " ++ show e2 ++ "]"
    show (DivideExpr   e1 e2)  = show e1 ++ " / " ++ show e2 ++ "]"
    show (MinTotalExpr e1 e2)  = "min(" ++ show e1 ++ ", " ++ show e2 ++ ")"
    show (MaxTotalExpr e1 e2)  = "max(" ++ show e1 ++ ", " ++ show e2 ++ ")"
    show (DropLowExpr  n  e)   = "dropLow(" ++ show n ++ ", " ++ show e ++ ")"
    show (DropHighExpr n  e)   = "dropLow(" ++ show n ++ ", " ++ show e ++ ")"
    show (SuccessExpr  n  e)   = "success(" ++ show n ++ ", " ++ show e ++ ")"
    show (MinValueExpr e)      = "min(" ++ show e ++ ")"
    show (MaxValueExpr e)      = "max(" ++ show e ++ ")"

instance Show DiceResult where
    show (DiceResult     d)       = show d 
    show (AddResult      r1 r2)   = '[' : (show r1) ++ " + " ++ show r2 ++ "]"
    show (SubtractResult r1 r2)   = '[' : (show r1) ++ " - " ++ show r2 ++ "]"
    show (MultiplyResult r1 r2)   = '[' : (show r1) ++ " * " ++ show r2 ++ "]"
    show (DivideResult   r1 r2)   = '[' : (show r1) ++ " / " ++ show r2 ++ "]"
    show r@(MinTotalResult r1 r2) = '[' : (show chosen) ++ " < " ++ show notChosen ++ "]"
                  where (chosen, notChosen) = totalSelector r
    show r@(MaxTotalResult r1 r2) = '[' : (show chosen) ++ " > " ++ show notChosen ++ "]"
                  where (chosen, notChosen) = totalSelector r
    show d@(DropLowResult  n  r)  = '[' : (show $ dropSelector d) ++ " <- " ++ show r ++ "]"
    show d@(DropHighResult n  r)  = '[' : (show $ dropSelector d) ++ " <- " ++ show r ++ "]"
    show d@(SuccessResult  n  r)  = '[' : (show $ successSelector d) ++ " <- " ++ show r ++ "]"
    show (MinValueResult r)       = '[' : (show $ valueSelector r) ++ " <- " ++ show r ++ "]"
    show (MaxValueResult r)       = '[' : (show $ valueSelector r) ++ " <- " ++ show r ++ "]"

{- Dice Rolling -}

rollDice :: (RandomGen r) => r -> DiceType -> [Int]
rollDice gen (Dice r c)           = take r $ randomRs (1, c) gen 
rollDice gen (CustomDice r sides) = take r $ map (sides !!) $ randomRs (0, length sides - 1) gen
rollDice gen (Constant n)         = [n] 

roll :: (RandomGen r) => r -> DiceExpression -> DiceResult
roll gen (DiceExpr     d)      = DiceResult     (rollDice gen d)
roll gen (AddExpr      e1 e2)  = AddResult      (roll g1 e1) (roll g2 e2)
                                     where (g1, g2) = split gen
roll gen (SubtractExpr e1 e2)  = SubtractResult (roll g1 e1) (roll g2 e2)
                                     where (g1, g2) = split gen
roll gen (MultiplyExpr e1 e2)  = MultiplyResult (roll g1 e1) (roll g2 e2)
                                     where (g1, g2) = split gen
roll gen (DivideExpr   e1 e2)  = DivideResult   (roll g1 e1) (roll g2 e2)
                                     where (g1, g2) = split gen
roll gen (MinTotalExpr e1 e2)  = MinTotalResult (roll g1 e1) (roll g2 e2)
                                     where (g1, g2) = split gen
roll gen (MaxTotalExpr e1 e2)  = MaxTotalResult (roll g1 e1) (roll g2 e2)
                                     where (g1, g2) = split gen
roll gen (DropLowExpr  n  e)   = DropLowResult  n (roll gen e)
roll gen (DropHighExpr n  e)   = DropHighResult n (roll gen e)
roll gen (SuccessExpr  n  e)   = SuccessResult  n (roll gen e)
roll gen (MinValueExpr e)      = MinValueResult (roll gen e)
roll gen (MaxValueExpr e)      = MaxValueResult (roll gen e)

{- DiceResult evaluation -}

eval :: DiceResult -> Int

eval (DiceResult     ds)    = sum ds

eval (AddResult      r1 r2) = eval r1 + eval r2
eval (SubtractResult r1 r2) = eval r1 - eval r2
eval (MultiplyResult r1 r2) = eval r1 * eval r2
eval (DivideResult   r1 r2) = eval r1 `div` eval r2

eval (MinTotalResult r1 r2) = min (eval r1) (eval r2)

eval (MaxTotalResult r1 r2) = max (eval r1) (eval r2)

eval d@(DropLowResult  _ _) = eval $ dropSelector d

eval d@(DropHighResult _ _) = eval $ dropSelector d

eval d@(SuccessResult _ _)  = evalCount $ successSelector d

eval (MinValueResult (DiceResult ds)) = minimum ds

eval (MaxValueResult (DiceResult ds)) = maximum ds

evalCount :: DiceResult -> Int
evalCount (DiceResult ds) = length ds

prettyEval :: DiceResult -> String
prettyEval dr = show (eval dr) ++ " = " ++ show dr 

{- Random Public Functions -}

exec :: (RandomGen r) => r -> DiceExpression -> Int
exec gen = eval . roll gen

prettyExec :: (RandomGen r) => r -> DiceExpression -> String
prettyExec gen = prettyEval . roll gen

{- Helper Functions -}

dropSelector :: DiceResult -> DiceResult
dropSelector (DropLowResult  n (DiceResult ds)) = DiceResult (drop n $ sort ds)
dropSelector (DropHighResult n (DiceResult ds)) = DiceResult (drop n $ reverse $ sort ds)

successSelector :: DiceResult -> DiceResult
successSelector (SuccessResult n (DiceResult ds)) = DiceResult (filter (>= n) ds)

valueSelector :: DiceResult -> DiceResult
valueSelector (MinValueResult (DiceResult ds)) = DiceResult [minimum ds]
valueSelector (MaxValueResult (DiceResult ds)) = DiceResult [maximum ds]

totalSelector :: DiceResult -> (DiceResult, DiceResult)
totalSelector (MinTotalResult r1 r2) = if eval r1 <= eval r2 then (r1, r2) else (r2, r1)
totalSelector (MaxTotalResult r1 r2) = if eval r1 >= eval r2 then (r1, r2) else (r2, r1)
